:py:mod:`anomalib.models.cflow.utils`
=====================================

.. py:module:: anomalib.models.cflow.utils

.. autoapi-nested-parse::

   Helper functions for CFlow implementation.



Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   anomalib.models.cflow.utils.get_logp
   anomalib.models.cflow.utils.positional_encoding_2d
   anomalib.models.cflow.utils.subnet_fc
   anomalib.models.cflow.utils.cflow_head



Attributes
~~~~~~~~~~

.. autoapisummary::

   anomalib.models.cflow.utils.logger


.. py:data:: logger
   

   

.. py:function:: get_logp(dim_feature_vector: int, p_u: torch.Tensor, logdet_j: torch.Tensor) -> torch.Tensor

   Returns the log likelihood estimation.

   :param dim_feature_vector: Dimensions of the condition vector
   :type dim_feature_vector: int
   :param p_u: Random variable u
   :type p_u: torch.Tensor
   :param logdet_j: log of determinant of jacobian returned from the invertable decoder
   :type logdet_j: torch.Tensor

   :returns: Log probability
   :rtype: torch.Tensor


.. py:function:: positional_encoding_2d(condition_vector: int, height: int, width: int) -> torch.Tensor

   Creates embedding to store relative position of the feature vector using sine and cosine functions.

   :param condition_vector: Length of the condition vector
   :type condition_vector: int
   :param height: H of the positions
   :type height: int
   :param width: W of the positions
   :type width: int

   :raises ValueError: Cannot generate encoding with conditional vector length not as multiple of 4

   :returns: condition_vector x HEIGHT x WIDTH position matrix
   :rtype: torch.Tensor


.. py:function:: subnet_fc(dims_in: int, dims_out: int)

   Subnetwork which predicts the affine coefficients.

   :param dims_in: input dimensions
   :type dims_in: int
   :param dims_out: output dimensions
   :type dims_out: int

   :returns: Feed-forward subnetwork
   :rtype: nn.Sequential


.. py:function:: cflow_head(condition_vector: int, coupling_blocks: int, clamp_alpha: float, n_features: int, permute_soft: bool = False) -> anomalib.models.components.freia.framework.SequenceINN

   Create invertible decoder network.

   :param condition_vector: length of the condition vector
   :type condition_vector: int
   :param coupling_blocks: number of coupling blocks to build the decoder
   :type coupling_blocks: int
   :param clamp_alpha: clamping value to avoid exploding values
   :type clamp_alpha: float
   :param n_features: number of decoder features
   :type n_features: int
   :param permute_soft: Whether to sample the permutation matrix :math:`R` from :math:`SO(N)`,
                        or to use hard permutations instead. Note, ``permute_soft=True`` is very slow
                        when working with >512 dimensions.
   :type permute_soft: bool

   :returns: decoder network block
   :rtype: SequenceINN


