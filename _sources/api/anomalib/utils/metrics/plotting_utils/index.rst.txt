:py:mod:`anomalib.utils.metrics.plotting_utils`
===============================================

.. py:module:: anomalib.utils.metrics.plotting_utils

.. autoapi-nested-parse::

   Helper functions to generate ROC-style plots of various metrics.



Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   anomalib.utils.metrics.plotting_utils.plot_figure



.. py:function:: plot_figure(x_vals: torch.Tensor, y_vals: torch.Tensor, auc: torch.Tensor, xlim: Tuple[float, float], ylim: Tuple[float, float], xlabel: str, ylabel: str, loc: str, title: str, sample_points: int = 1000) -> Tuple[matplotlib.figure.Figure, matplotlib.axis.Axis]

   Generate a simple, ROC-style plot, where x_vals is plotted against y_vals.

   Note that a subsampling is applied if > sample_points are present in x/y, as matplotlib plotting draws
   every single plot which takes very long, especially for high-resolution segmentations.

   :param x_vals: x values to plot
   :type x_vals: Tensor
   :param y_vals: y values to plot
   :type y_vals: Tensor
   :param auc: normalized area under the curve spanned by x_vals, y_vals
   :type auc: Tensor
   :param xlim: displayed range for x-axis
   :type xlim: Tuple[float, float]
   :param ylim: displayed range for y-axis
   :type ylim: Tuple[float, float]
   :param xlabel: label of x axis
   :type xlabel: str
   :param ylabel: label of y axis
   :type ylabel: str
   :param loc: string-based legend location, for details see
               https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html
   :type loc: str
   :param title: title of the plot
   :type title: str
   :param sample_points: number of sampling points to subsample x_vals/y_vals with
   :type sample_points: int

   :returns: Figure and the contained Axis
   :rtype: Tuple[Figure, Axis]


